/**
 * 해당 문제는 10844번 문제와 유사한 방식으로 분석이 가능했다.
 * 오르막수는 오름차순을 이루는 수를 말한다. 연속되는 수가 있어도 상관 없음.
 * 예) 0001, 012223, 145589
 *
 * DP[n][i]라고 할 때, n은 수의 길이, i는 n자리수의 일의자리에 올 수 있는 수를 말함
 * 먼저 한자리 수인 0 ~ 9 모두 오르막수로 볼 수 있음
 * DP[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
 * DP[2] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * DP[3] = [1. 3, 6, 10, 15, 21, 38, 36, 45, 55];
 *
 * 두자리수, 세자리수를 살펴보자.
 * 이전 자리수(한자리수)의 뒤로 올 수 있는 수의 가짓수를 생각해보면
 * DP[2][0] = 0이 올 수 있는 수는 0뿐이므로 가짓수 1개
 * DP[2][1] = 1이 올 수 있는 수는 0, 1 = 가짓수 2개
 * DP[2][2] = 2가 올 수 있는 수는 0, 1, 2 = 가짓수 3개
 * ...
 *
 * DP[3][0] = 0이 올 수 있는 수는 00뿐이므로 가짓수는 1개
 * DP[3][1] = 1이 올 수 있는 수는 01, 11 = 가짓수는 2개
 * DP[3][2] = 2가 올 수 있는 수는 02, 12, 22 = 가짓수 3개
 * ...
 *
 * 규칙을 찾아 점화식으로 나타내면
 * DP[n][i] = DP[n-1][i] + DP[n][i-1]
 */

const N = +require('fs').readFileSync('./input.txt').toString().trim();
const mod = 10007;
const dp = Array.from(new Array(N + 1), () => new Array(10).fill(1));

for (let n = 2; n <= N; n++) {
  for (let i = 0; i < 10; i++) {
    dp[n][i] = dp[n - 1][i] + (dp[n][i - 1] || 0);
    dp[n][i] %= mod;
  }
}

let sum = 0;
for (let k = 0; k < 10; k++) {
  sum += dp[N][k];
}
console.log(sum % mod);
